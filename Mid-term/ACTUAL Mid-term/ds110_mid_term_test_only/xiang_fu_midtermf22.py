# -*- coding: utf-8 -*-
"""Xiang_Fu_MidtermF22.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P6ceFmmQZR0DBYJ_7gO9z_xIe_pKzuxC

# Midterm - DS 110 Fall 2022

**For this midterm, you may refer to the Internet or your notes, but you must add a comment to your answer citing the source(s) that helped you.  This includes using the lecture notes.  Include a URL for a web source or the number of the lecture for lecture materials.  Failure to cite sources could result in point penalties or, in extreme cases, an academic integrity case.**

**You also may not collaborate with other students.**

**The deadline is 3:35pm on Thursday November 3.**

## 1) Loops (15 points)

Write a function countdowns() that takes a list of integers as its sole argument.  The function should then print a "countdown" for each item in the list, starting from that number and ending in 0, with one number per line.  For example, if the input were [3, 4, 2], then the output would be:
"""

3
2
1
0
4
3
2
1
0
2
1
0

"""The function can return void."""

# def countdowns(lst): TODO

def countdowns(list):
    for i in list:
        for j in range(i, -1, -1):
            print(j)

# Test
countdowns([3,4,2])

"""## 2) Dictionaries (10 points)

Write a function max_dict_merge() that takes two dictionaries as arguments and returns a third dictionary that is distinct from the other two (don't modify the input dictionaries).  If a key is in one of the dictionaries but not the other, that key should have the same value it had in its old dictionary in the new one.  But if the key was in both dictionaries, the new value in the new dictionary should be the max of the old values.  For example, max_dict_merge({'a':2,'b':3}, {'b':4,'c':5}) creates the new dictionary {'a':2,'b':4,'c':5}.
"""

# def max_dict_merge(d1, d2): TODO

def max_dict_merge(dict1, dict2):
    dict3 = {}
    for key in dict1:
        if key in dict2:
            dict3[key] = max(dict1[key], dict2[key])
        else:
            dict3[key] = dict1[key]
    for key in dict2:
        if key not in dict3:
            dict3[key] = dict2[key]
    return dict3

# Test
max_dict_merge({'a':2,'b':3}, {'b':4,'c':5})

"""## 3) DataFrames (10 points)

a) Using the file genre_region_totals.csv, write code that prints the video game genre that sold the most worldwide.  (Note that "Worldwide" is a possible value for the region column.)
"""

# Google colab only
from google.colab import files
import io

uploaded = files.upload() # pick genre_region_totals.csv

import pandas as pd

df = pd.read_csv('genre_region_totals.csv', index_col = 'genre')

df.head()

# a) TODO

"""b) Now write code to print the "Puzzle" game sales in "North America".  (Hint: Your last step should be a call to loc[].)  The file has the sales records in millions, and you can keep them in that format."""

# b) TODO

print(df[(df['genre'] == 'puzzle') & (df['region'] == 'North America')].iloc[0]['total'])

"""## 4) Objects (15 points)

Write a class Transaction that contains fields for a string name of the Transaction and a floating point amount of the Transaction.

* Write a constructor for this class that takes the name and amount as arguments and initializes the fields with those values.
* Write a method sum() that takes the present Transaction and another transaction (an argument) and returns the sum of their two values.  If the argument isn't a Transaction, throw a ValueError.
* Write a function that isn't a method, sum_all(), that takes a list of Transactions as an argument, and returns their total sum. (You don't need to check the types of the items in the list.)
"""

# class Transaction:  TODO

class Transaction:
    def __init__(self, name, amount):
        self.name = name
        self.amount = amount
    
    def sum(self, transaction):
        if not isinstance(transaction, Transaction):
            raise ValueError
        return self.amount + transaction.amount
    
    def sum_all(transactions):
      total = 0
      for trans in transactions:
        total += trans.amount
      return total

t = Transaction("Lunch", 12.99)
t2 = Transaction("Dinner", 18.99)
print(t.sum(t2)) # Prints roughly 31.98
print(sum_all([t,t2])) # Also prints roughly 31.98

t.sum(2) # raise ValueError

"""## 5) Recursion (10 points)

Write a recursive function tree_max() that takes a binary tree as an argument and returns the largest value in the tree.  (Note that it is not a binary *search* tree, so the largest value could be anywhere in the tree.)  Hint:  you could consider the value of None branches to be negative infinity, float('-inf').
"""

class BinaryTree:
  def __init__(self, left, right, val):
    self.left = left
    self.right = right
    self.val = val

small_tree = BinaryTree(BinaryTree(None,None,3), BinaryTree(None,None,2), 1)
larger_tree = BinaryTree(BinaryTree(None,None,4), small_tree, 5)

# def tree_max(tree):  TODO

def tree_max(tree):
    if tree is None:
        return float('-inf')
    return max(tree.val, tree_max(tree.left), tree_max(tree.right))

tree_max(small_tree) # Should return 3

tree_max(larger_tree) # Should return 5